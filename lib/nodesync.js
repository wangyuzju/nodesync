// Generated by CoffeeScript 1.6.3
(function() {
  var Filter, MatchContainer, config, fc, filter, fs, initMain, jch, params, parseArgv, path, remote, startWatch, watch;

  fs = require('fs');

  path = require('path');

  watch = require("watch-project");

  jch = require("jch");

  params = require('commander');

  remote = require('./upload');

  fc = require('./filechange');

  config = require('./config');

  console.error = function(s) {
    return console.log("\u001b[1;31m" + s + "\u001b[0m");
  };

  console.info = function(s) {
    return console.log("\u001b[36m" + s + "\u001b[0m");
  };

  console.warn = function(s) {
    return console.log("\u001b[35m" + s + "\u001b[0m");
  };

  startWatch = function(opts) {
    var filter;
    if (!fs.existsSync(opts.path)) {
      console.error("Error: ");
      console.log("\tDirectory '" + opts.path + "' is not Exist!");
      return;
    }
    if (opts.beta) {
      console.warn("[Beta Mode Enable: works well on linux]");
    }
    console.log("Local : >>>");
    console.log("\tWatching : '" + opts.path + "'");
    console.log("\tConnect to: '" + opts.host + "'");
    console.log("");
    remote.connect(opts.host, opts.pathto, opts.force, opts.debug);
    filter = new Filter(opts.ignore);
    watch(opts.path, {
      stable: !opts.beta
    }, function(e) {
      var start;
      start = new Date();
      if (filter.match(path.basename(e.filename))) {
        console.log(new Date() - start);
        return;
      }
      console.log("[" + ((new Date()).toTimeString().slice(0, 8)) + "] Local: >>>\u001b[1;4m" + e.type + "\u001b[0m [" + e.filename + "]");
      if (opts.debug) {
        console.log("   old:\t" + e.oid);
        console.log("   new:\t" + (e.nid || e.oid));
      }
      switch (e.type) {
        case 'mkdir':
          return remote.mkdir(e.filename);
        case 'change':
        case 'create':
          remote.save(e.filename, e.oid);
          if ((path.basename(e.filename)).slice(0, 3) === 'jch') {
            return jch.parse(e.filename);
          }
          break;
        case 'delete':
        case 'rmdir':
          return remote["delete"](e.filename, e.oid);
        case 'mvfile':
        case 'mvdir':
          return remote.move(e.oname, e.oid, e.filename);
      }
    });
    return process.on('SIGINT', function() {
      return process.exit();
    });
  };

  initMain = function() {
    var conf, key, value;
    params.option('-f, --force', 'force sync mode ignore without checking file\'s MD5').option('-b, --beta', 'enter beta version, only stable on linux').option('-d, --debug', 'show more detailed debug info').version('0.0.8').parse(process.argv);
    conf = config.load(path.resolve('.m3dsync_config'));
    if (true) {
      for (key in conf) {
        value = conf[key];
        if (params[key] == null) {
          params[key] = value;
        }
      }
      return startWatch(params);
    }
  };

  parseArgv = function() {
    switch (process.argv[2]) {
      case 'resolve':
        return console.log("resolve conflict!");
      default:
        return initMain();
    }
  };

  module.exports.run = parseArgv;

  /* #   #*/


  /* #   #   #*/


  MatchContainer = (function() {
    function MatchContainer() {
      this.matchList = {};
    }

    MatchContainer.prototype.add = function(l, val) {
      if (this.matchList[l]) {
        return this.matchList[l][val] = true;
      } else {
        this.matchList[l] = {};
        return this.matchList[l][value] = true;
      }
    };

    return MatchContainer;

  })();

  Filter = (function() {
    function Filter(config) {
      this.config = config;
      this.prepare();
    }

    Filter.prototype.addMatch = function(obj, l, value) {
      if (obj[l]) {
        return obj[l][value] = true;
      } else {
        obj[l] = {};
        return obj[l][value] = true;
      }
    };

    Filter.prototype.prepare = function() {
      var val, _i, _len, _ref, _results;
      this.leftMatch = {};
      this.rightMatch = {};
      this.totalMatch = {};
      _ref = this.config;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        val = _ref[_i];
        if (val[0] === "*") {
          _results.push(this.addMatch(this.rightMatch, val.length - 1, val.slice(1)));
        } else if (val.slice(-1) === "*") {
          _results.push(this.addMatch(this.leftMatch, val.length - 1, val.slice(0, -1)));
        } else {
          _results.push(this.totalMatch[val.length] = val);
        }
      }
      return _results;
    };

    Filter.prototype.match = function(s) {
      var l, len, matchList, _ref, _ref1;
      console.log(s);
      console.log(this.leftMatch);
      l = s.length;
      _ref = this.rightMatch;
      for (len in _ref) {
        matchList = _ref[len];
        if (len >= l) {
          break;
        }
        console.info(len);
        if (matchList[s.slice(-len)]) {
          return true;
        }
      }
      _ref1 = this.leftMatch;
      for (len in _ref1) {
        matchList = _ref1[len];
        if (len >= l) {
          break;
        }
        console.error(len);
        if (matchList[s.slice(0, len)]) {
          return true;
        }
      }
      if (this.totalMatch[l]) {
        return true;
      }
      return false;
    };

    return Filter;

  })();

  filter = function() {};

}).call(this);
