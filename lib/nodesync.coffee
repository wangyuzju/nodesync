fs = require 'fs'
path = require 'path'
watch = require "watch-project"
jch = require "jch"
params = require 'commander'
remote = require './upload'
fc = require './filechange'
config = require './config'


console.error = (s)->
  console.log("\u001b[1;31m#{s}\u001b[0m")
# used for log messages generated by other program
console.info = (s)->
  console.log "\u001b[36m#{s}\u001b[0m"
# used for log important messages
console.warn = (s)->
  console.log "\u001b[35m#{s}\u001b[0m"



startWatch = (opts)->

  # check watch target file exists
  if not fs.existsSync opts.path
    console.error "Error: "
    console.log "\tDirectory '#{ opts.path }' is not Exist!"
    return


  # init local
  console.warn "[Beta Mode Enable: works well on linux]" if opts.beta
  console.log "Local : >>>"
  console.log "\tWatching : '#{opts.path}'"
  console.log "\tConnect to: '#{opts.host}'"
  #console.log "\tConnecting ... '#{opts.host}'"
  console.log ""

  # init server
  remote.connect opts.host, opts.pathto, opts.force, opts.debug

  #init flie filter
  filter = new Filter (opts.ignore)

  #dispatch events occured during the program is not running
  #watch.ready ()->
  #  fs.readFile '.m3ddata', {encoding: 'utf-8'}, (err, data)->
  #    return if err
  #    fc.dispatchEvent watch, data


  watch opts.path,
    stable: !opts.beta
  , (e)->
    #filter ignored files
    start = new Date()
    if filter.match (path.basename(e.filename))
      console.log(new Date() - start)
      return

    #console.log '\u001b[1;4;35m>>>>>>>>>>>>>>>>>>>\u001b[0m'
    console.log "[#{(new Date()).toTimeString().slice(0,8)}] Local: >>>\u001b[1;4m#{e.type}\u001b[0m [#{e.filename}]"
    if opts.debug
      console.log "   old:\t#{e.oid}"
      console.log "   new:\t#{e.nid || e.oid}"

    switch e.type
      when 'mkdir'
        remote.mkdir e.filename
      when 'change', 'create'
        remote.save e.filename, e.oid
        if (path.basename e.filename)[0...3] is 'jch'
          jch.parse(e.filename)
      when 'delete', 'rmdir'
        remote.delete e.filename, e.oid
      when 'mvfile', 'mvdir'
        remote.move e.oname, e.oid, e.filename
      else


  #save watch status for trigger change events next time
  process.on 'SIGINT', ()->
    #fs.writeFileSync '.m3ddata', watch.status()
    do process.exit



initMain = ()->
  # handle command-line args
  params
    .option('-f, --force', 'force sync mode ignore without checking file\'s MD5')

    .option('-b, --beta', 'enter beta version, only stable on linux')
    .option('-d, --debug', 'show more detailed debug info')
    .version('0.0.8')

    .parse(process.argv)


  conf = config.load( path.resolve('.m3dsync_config') )
  # first running this program, will ask user to input configuration informatin rather than start watching
  if true
    #
    for key, value of conf
      params[key] ?= value

    # startWatch
    startWatch(params)


parseArgv = ()->
  switch process.argv[2]
    when 'resolve'
      console.log "resolve conflict!"
      # fix sync error through svn
    else
      # enter the main sync program
      initMain()

module.exports.run = parseArgv

### #   # ##### ##### ####   #   #   #   #
 #  ##  #   #   #     #   #  ##  #       #
 #  # # #   #   ####  #  #   # # #  ###  #
 #  #  ##   #   #     #   #  #  ##       #
### #   #   #   ##### #    # #   # #   # #####

# matched pattern container solving IDs with same length such as ".swp" and ".bak"
class MatchContainer
  constructor: ()->
    @matchList = {}
    # used to store ids with same length
    #@idList = {}

  add: (l, val)->
    if @matchList[l]
      @matchList[l][val] = true
    else
      @matchList[l] = {}
      @matchList[l][value] = true


# check if a filenamre matched
class Filter
  constructor: (@config)->
    @prepare()



  addMatch: (obj, l, value)->
    if obj[l]
      obj[l][value] = true
    else
      obj[l] = {}
      obj[l][value] = true


  prepare: ()->
    @leftMatch = {}
    @rightMatch = {}
    @totalMatch = {}
    for val in @config
      if val[0] is "*"
        # right hand check list
        @addMatch (@rightMatch, val.length - 1, val[1...])
        #@rightMatch[val.length - 1] = val[1..]
      else if val[-1..] is "*"
        # left hand ckeck list
        @addMatch (@leftMatch, val.length - 1, val[0...-1])
        #@leftMatch[val.length - 1] = val[0...-1]
      else
        @totalMatch[val.length] = val

  match: (s)->
    console.log s
    console.log (@leftMatch)
    l = s.length
    # right side check first for it's much common
    for len, matchList of @rightMatch
      break if len >= l
      console.info (len)
      return true if matchList[ s.slice(-len) ]
    # left side check
    for len, matchList of @leftMatch
      break if len >= l
      console.error (len)
      return true if matchList[ s.slice(0, len) ]
    # full check
    return true if @totalMatch[l]
    return false



filter = ()->